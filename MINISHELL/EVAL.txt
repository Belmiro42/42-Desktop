- No Segfault / Unexpected Termination

- Leaks

 - "-Wall -Wextra -Werror"

- Compiles without any errors

- The Makefile must not re-link

- Execute a simple command with an absolute path like /bin/ls, or any other command without any options.

- How many global variables are used? Why? Ask the evaluated student to give you a concrete example of why it feels mandatory or logical.

- Check the global variable. This global variable cannot provide any other information or data access than the number of a received signal.

- Test an empty command.

- Test only spaces or tabs.

- Execute a simple command with an absolute path like /bin/ls, or any other command with arguments but without any quotes or double quotes.

- Execute the echo command with or without arguments, or the -n option.

- Execute exit command with or without arguments.

- Execute echo $?

- ctrl-C in an empty prompt should display a new line with a new prompt.
		-ctrl-C in a prompt after you wrote some stuff should display a new line with a new prompt.

- ctrl-\ in an empty prompt should not do anything.
		ctrl-\ in a prompt after you wrote some stuff should not do anything.

- ctrl-D in an empty prompt should quit minishell --> RELAUNCH!
		ctrl-D in a prompt after you wrote some stuff should not do anything.

- Try ctrl-C after running a blocking command like cat without arguments or grep “something“.
- Try ctrl-\ after running a blocking command like cat without arguments or grep “something“.
- Try ctrl-D after running a blocking command like cat without arguments or grep “something“.

- Try a command like : echo "cat lol.c | cat > lol.c"

- Execute commands with single quotes as arguments.
- Try empty arguments.
- Try environment variables, whitespaces, pipes, redirection in the single quotes.
- echo '$USER' must print "$USER".

- Check if env shows you the current environment variables.

- Export environment variables, create new ones and replace old ones. Check the result with env.
- Use unset to remove some of them. Check the result with env.

- Use the command cd to move the working directory and check if you are in the right directory with /bin/ls
- Also, try '.' and '..' as arguments.

- Use the command pwd.

- Execute commands but this time use a relative path.

- Unset the $PATH and ensure commands are not working anymore. Execute commands but this time without any path (ls, wc, awk and so forth).

- Set the $PATH to a multiple directory value (directory1:directory2) and ensure that directories are checked in order from left to right.

- Execute commands with redirections < and/or > Test << redirection (it doesn't have to update the history).

- Execute commands with pipes like 'cat file | grep bla | more'
- Try some wrong commands like 'ls filethatdoesntexist | grep bla | more'
- Try to mix pipes and redirections.

- Type a command line, then use ctrl-C and press "Enter". The buffer should be clean and there should be nothing left to execute.

- Can we navigate through history using Up and Down? Can we retry some command?

- Execute commands that should not work like 'dsbksdgbksdghsd'. Ensure minishell doesn't crash and prints an error.

- 'cat | cat | ls' should behave in a "normal way".

- Try to execute a long command with a ton of arguments.

- Execute echo with some environment variables ($variable) as arguments.

- Check that $ is interpreted as an environment variable.

- Check that double quotes interpolate $.

- Check that USER exists. Otherwise, set it.

- echo "$USER" should print the value of the USER variable.

- Use &&, || and parenthesis with commands and ensure minishell behaves the same way bash does.

- Use wildcards in arguments in the current working directory.
